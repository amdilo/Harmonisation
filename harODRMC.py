#!/usr/bin/env python

""" FCDR harmonisation modules
    Project:        H2020 FIDUCEO
    Author:         Arta Dilo \NPL MM
    Reviewer:       Peter Harris \NPL MM, Sam Hunt \NPL ECO
    Date created:   24-01-2017
    Last update:    20-04-2017
    Version:        12.0

Evaluate harmonisation uncertainty for the error structure in measurements
via Monte Carlo (MC). An MC trial generates data from best estimates of 
harmonisation variables evaluated from regression on simulated/real sensor data,   
and errors generated by respecting the full error structure. 

Weighted ODR regression is performed on MC generated data, and covariance of 
coefficients from MC trials is used to evaluate harmonisation uncertainty on 
FCDR radiance. """

from numpy import ones, zeros, savetxt
from datetime import datetime as dt
from os.path import isfile, join as pjoin
from optparse import OptionParser
from random import sample
import readHD as rhd
import errStruct as mce 
from harFun import seriesODR
import unpFun as upf
import visFun as vis
import plotHaR as phr


# Set GLOBAL variables 
datadir = "D:\Projects\FIDUCEO\Data" # main data folder in laptop
#datadir = "/home/ad6/Data" # main data folder in eoserver
#datadir = "/group_workspaces/cems2/fiduceo/Data/Matchup_Simulated/Data" # in CEMS
mcrdir = pjoin(datadir, 'Results') # folder for MC trials results
#pltdir = pjoin(datadir, 'Graphs') # folder for png images of graphs
hvars = 12 # number of columns in the H data matrices of a series


""" Perform multiple-pair regression with ODR """
def multipH(filelist, series, dstype):
    
    p = series.nocoefs # number of calibration parameters
    m = series.novars # # number of measured variables
    nos = series.nosensors # number of sensors in the series
    slist = series.sslab # list of sensors in the series
    inCoef = series.preHcoef # input coefficients to simulations
    
    # Create array of initial beta values for the ODR fit
    hsCoef = zeros((nos,p))    
    # Keep the same values as input coefficients in inCoef 
    for sno in range(nos):
        sl = slist[sno]
        hsCoef[sno,:] = inCoef[sl][0:p]    

    b0 = hsCoef.flatten('A') # format to ODR input for initial values
    print '\n\nInitial beta values for ODR'
    print b0
    
    if series.notime: # work with not time-dependant dataset
        folder = pjoin(datadir, 'newSim_notime') # data folder
        # columns for X variables in the H matrices
        cols = [x for x in range(hvars) if (x!=5 and x<10)]

        ## create ifixb arrays; fix a coeffs for reference sensor
        #parfix = zeros(nos*p, dtype=int)
        #parfix[0:p] = 1
        #fixb = parfix.tolist() # ifixb ODR parameter
        #print '\n\nifixb array for sensors', slist
        #print fixb
        fixb = None
        fixx = None
        
    else: # work with data in the main/time-dependent data folder        
        folder = pjoin(datadir, 'newSim') # data folder
        # columns for X variables in the H matrices
        cols = [x for x in range(hvars) if x < 11]
    
        # create ifixb arrays; fix a3 for all series' sensors
        parfix = zeros(nos*p, dtype=int)
        for sidx in range(1,nos):
            parfix[p*sidx:p*sidx+p-1] = 1
        fixb = parfix.tolist() # ifixb ODR parameter
        print '\n\nifixb array for sensors', slist
        print fixb
        
        # create ifixx arrays; fix orbit temperature To for sensors
        varfix = ones(m*2+1, dtype=int)
        varfix[m] = 0 # fix To for 1st sensor 
        varfix[2*m] = 0 # fix To for 2nd sensor 
        fixx = varfix.tolist() # ifixx ODR parameter
        print '\nifixx array', fixx        
        
    #if Hd.shape[1] != hvars:
    #    sys.exit('Incorrect shape of harmonisation matrices')
    
    # work with real datasets; currently a different folder for the data
    if dstype == 'r': 
        folder = pjoin(datadir, 'Harm_RealData') # real data folder

    # read data from the list of netCDF files    
    Im,Hd,Hr,Hs,sp,mutime,corL,Is,sl1,mxsl1,sl2,mxsl2,CsU1,CictU1,CsU2,CictU2 = rhd.rHData(folder, filelist) 
    series.setIm(Im) # set the series index matrix      
    print '\nIm matrix of matchups per pair:' 
    print Im
    print '\nIs matrix of scanlines per pair:'
    print Is  

    # perform odr on all sensors from the list
    sodr = seriesODR(Hd[:,cols],Hd[:,-1],Hr[:,cols],Hr[:,-1],b0,sp,series,fixb,fixx)
    print '\nODR output for sensors', slist, '\n'
    sodr.pprint() # print summary of odr results 
    
    return sodr,Hr,Hs,sp,mutime,corL,Is,sl1,mxsl1,sl2,mxsl2,CsU1,CictU1,CsU2,CictU2,fixb,fixx

""" Run an MC trial on data generated from best estimates returned from 
ODR regression on real/simulated data perturbed by errors generated for the 
full error structure (uses Peter & Sam's weight matrix) """
def MCtrial(X,Y,Hr,Hs,spair,corL,Is,slt1,mcnt1,slt2,mcnt2,CsUr,CbbUr,CsU,CbbU,series,b0,fb,fx):
    
    td = series.notime # model time dependancy 
    p = series.nocoefs # number of calibration parameters    
    nos = series.nosensors # number of sensors in the series
    mcb = zeros(nos*p+1) # array to store ODR beta vals and info for the trial
    
    # Generate errors with the weight matrix W from Peter & Sam
    errStr = mce.genErr(Hr,Hs,CsUr,CbbUr,CsU,CbbU,Is,slt1,mcnt1,slt2,mcnt2,corL,series)
    
    # select columns in Hr and error matrix corresponding to X vars; hard-coded
    if td: # non-time-dependent model&data, i.e. no To columns in X vars
        cols = [x for x in range(Hr.shape[1]) if (x!=5 and x<10)]
    else: # all columns but K (the last)
        cols = [x for x in range(Hr.shape[1]) if x < hvars-1]

    # add errors to X and Y best estimates
    Xdt = X.T + errStr[:,cols] # X variables
    Ydt = Y + errStr[:,-1] # Y var: K, last column in error matrix
    
    # run ODR on new X & Y vals and weights 
    mcodr = seriesODR(Xdt,Ydt,Hr[:,cols],Hr[:,-1],b0,spair,series,fb,fx)
    
    # store ODR fit coefficients and reason for halting
    mcb[0:-1] = mcodr.beta
    mcb[-1] = mcodr.info
    
    return mcb

# Plot harmonisation results for series sensors    
def plotODRMC(sodr, mcb_fn, series, nobj):
    
    nos = series.nosensors # number of sensors in the series
    m = series.novars # # number of measured variables
    p = series.nocoefs # number of calibration parameters
    slist = series.sslab # list of sensors in the series
    inCoef = series.preHcoef # input coefficients to simulations
    Im = series.im # index matrix for series matchups
    
    mpbeta = sodr.beta # calibration coeffs of fitted sensors
    mpcov = sodr.cov_beta # coefficients covariance
    X = (sodr.xplus).transpose()   
    
    mpcor = vis.cov2cor(mpcov) # coeffs' correlation matrix
    print '\nODR correlation of harmonisation coefficients for pairs '+', '.join(filelist) +'\n'
    print mpcor
    
    mccov = phr.mcCorr(mcb_fn, series, mpbeta, mpcov, '')
    print '\nMC correlation of harmonisation coefficients for pairs '+', '.join(filelist) +'\n'
    mccor = vis.cov2cor(mccov) # MC correlation matrix
    print mccor    
    
    """ Extract coefficients and covariance of each sensor, 
    compute and plot radiance with 4*sigma uncertainty """
    for sno in range(1,nos): # loop through fitted sensor
        sl = slist[sno] # sensor label
        slab = int(sl[1:3]) # two-digits label in Im matrix
        
        sMidx, eMidx = rhd.sliceHidx(Im, slab) # 1st and last record index
        print '\nFirst and last record for sensor', slab, '[', sMidx, eMidx,']'
        selMU = sample(xrange(sMidx, eMidx), nobj) # Select matchups for plotting    
        
        inC = inCoef[sl] # input coeffs to simulations
        print 'Input coefficients for sensor', slab, ':', inC
        inL = avhrrNx.measEq(X[selMU, m+1:2*m+1], inC) # radiance from input coeffs
        
        calC = mpbeta[sno*p:(sno+1)*p] # calib. coeffs for sensor slab
        print 'Fitted coefficients for sensor', slab, ':', calC
        calL = avhrrNx.measEq(X[selMU, m+1:2*m+1], calC) # calibrated radiance 
        
        covCC = mccov[sno*p:(sno+1)*p,sno*p:(sno+1)*p] # coeffs covariance from odr
        print 'MC covariance of coefficients for sensor', slab
        print covCC
        # radiance uncertainty from harmonisation
        cLU = avhrrNx.harUnc(X[selMU, m+1:2*m+1],calC,covCC) 
    
        # graphs of radiance bias with 2sigma error bars
        plot_ttl = sl + ' Radiance bias and ' + r'$4*\sigma$'+ ' uncertainty from multiple-pairs ODR+MC'
        vis.LbiasU(inL, calL, cLU, 4, plot_ttl) 
        
    return mccor

if __name__ == "__main__":

    usage = "usage: %prog time-flag data-type no-trials series-label"
    parser = OptionParser(usage=usage)
    (options, args) = parser.parse_args()

    if len(args) < 3 :
        parser.error("Not enough input arguments")

    # 1st argument: boolean, defines what dataset to work with 
    notime = args[0] 
    if not isinstance(notime, bool): # if input is not True/False
        notime = str(args[0]).lower()
        if notime in ("yes", "true", "t", "1"):
            notime = True # work with not-time dependent dataset
        else:
            notime = False # work with time dependent dataset
    
    dtype = args[1] # 2nd argument: type of dataset, r for real, s for simulated
    notr = int(args[2]) # 3rd argument: number of MC trials
    sslab = args[3] # 4th argument: series label e.g. avhrr; currently not used
    
    # TODO: 5th argument the list of netCDFs with matchup harmonisation data
    #filelist = args[4] # input from a text file 
    filelist = ["m02_n19.nc","m02_n15.nc","n19_n15.nc","n15_n14.nc"]
    #filelist = ["m02_n15.nc","n15_n14.nc"]
    
    # compile filename where beta coefficients of MC trials are stored
    fn = 'odrmc_'
    if dtype =='r':
        fn += 'rd_'
    if notime:
        fn += 'notd_'
    else:
        fn += 'td_'    
    fn += 'beta.txt' # filename
    fn = pjoin(mcrdir, fn) # path and filename
   
    # Time the execution of the script
    st = dt.now() # start time of script run
    
    # create instance of series class, currently assumed 'avhrr' only
    # TODO: change for different series label
    avhrrNx = upf.avhrr(datadir, filelist, notime) 
    
    # perform regression on multiple pairs from real/simulated dataset
    sodr,Hr,Hs,sp,mt,corL,Is,sl1,mxsl1,sl2,mxsl2,CspU1,CbbU1,CspU2,CbbU2,fb,fx = multipH(filelist, avhrrNx, dtype)
    
    # Generate data for Monte Carlo trials 
    Y = sodr.y # best estimate of adjustement values K
    # best est. of explanatory vars (Cs,Cict,CE,Lict,To) for 2 sensors, and Lref 
    X = sodr.xplus
    beta = sodr.beta # beta coeffs from odr fit on real/simulated data

    p = avhrrNx.nocoefs # number of calibration parameters      
    nos = avhrrNx.nosensors # number of sensors
    
    # plot results from a previous run of ODR+MC
    if isfile(fn):
        mcCor = plotODRMC(sodr, fn, avhrrNx, 250)
        
    # perform notr MC iterations of ODR runs on best estimate + error data
    mcbeta = zeros([notr, p*nos+1]) # array to store beta vals &ODR info of MC trials
    for i in range(notr): # 
        mcbeta[i] = MCtrial(X,Y,Hr,Hs,sp,corL,Is,sl1,mxsl1,sl2,mxsl2,CspU1,CbbU1,CspU2,CbbU2,avhrrNx,beta,fb,fx)    
    savetxt(fn, mcbeta, delimiter=',') # store MC beta coefficients to file
        
    et = dt.now() # end of script run
    exect = (et-st).total_seconds()
    print '\nTime taken for fitting pairs', filelist, 'in', notr, 'MC trials'
    print (exect/60.), 'minutes\n'
